input {
  file {
    id => "csv001"
    add_field => { "[@metadata][source_type]" => "csv001" }
    path => "/home/ubuntu/intel/feeds/csv/alienvault-generic.csv"
    # sincedb_path => "/var/tmp/.sincedb_csv_filename"
    sincedb_path => "/dev/null"
    start_position => "beginning"
  }

  file {
    id => "csv002"
    add_field => { "[@metadata][source_type]" => "csv002" }
    path => "/home/ubuntu/intel/feeds/csv/appspot-malwaredomainlist.csv"
    # sincedb_path => "/var/tmp/.sincedb_csv_filename"
    sincedb_path => "/dev/null"
    start_position => "beginning"
  }

}

filter {
  if [@metadata][source_type] == "csv001" {
    grok {
      match => { "message" => "%{IP:intel-value}" }
    }

    mutate {
      add_field => {
        "intel-source" => "Alienvault Reputation Generic Feed"
        "intel-analysis" => "2"
        "comments" => ""
        "intel-category" => "Network Activity"
        "intel-uuid" => ""
        "intel-timestamp" => "%{@timestamp}"
        "exportable_to_ids" => "true"
        "intel_type" => "ip-dst"
        "threat_level_id" => "2"
      }
    }
  }

  if [@metadata][source_type] == "csv002" {
    grok {
      match => { "message" => "%{IP:intel-value}" }
    }

    mutate {
      add_field => {
        "intel-source" => "Appspot Malware Domain List"
        "intel-analysis" => "2"
        "comments" => ""
        "intel-category" => "Network Activity"
        "intel-uuid" => ""
        "intel-timestamp" => "%{@timestamp}"
        "exportable_to_ids" => "true"
        "intel_type" => "ip-dst"
        "threat_level_id" => "2"
      }
    }
  }


  # Common Information
  uuid {
    target => "intel-uuid"
    "overwrite" => true
  }

  mutate {
    convert => {
      "intel-analysis" => "integer"
      "threat_level_id" => "integer"
      "exportable_to_ids" => "boolean"
    }

    remove_field => [ "message" ]
  }
  translate {
    field => "intel-analysis"
    destination => "intel-analysis-code"
    dictionary => [
        "0", "Initial",
        "1", "Ongoing",
        "2", "Complete"
    ]
  }

  translate {
    field => "threat_level_id"
    destination => "threat_level_code"
    dictionary => [
        "1", "High",
        "2", "Medium",
        "3", "Low",
        "4", "Undefined"
    ]
  }

  grok {
    match => { "intel-value" => "%{IP:intel-ip}"}
    tag_on_failure => [ ]
  }

  # add geoip attributes
  geoip {
    source => "intel-ip"
    tag_on_failure => [ ]
  }

  # Fingerprinting to remove duplicates
  fingerprint {
    concatenate_sources => true
    source => ["intel_type", "intel-value"]
    target => "[@metadata][fingerprint]"
    method => "MURMUR3"
  }

  if "_jsonparsefailure" in [tags] {
    drop { }
  }

}

output {
stdout { codec => rubydebug }
elasticsearch {
    hosts => localhost
    document_id => "%{[@metadata][fingerprint]}"
    index => "csv-%{+YYYY.MM.dd}"
}
}
